# 자바스크립트 개발자라면 알아야하는 핵심 컨셉 33개 

## by leonardomso & jakeseo_me [#](https://github.com/leonardomso/33-js-concepts) [#](https://velog.io/@jakeseo_me/자바스크립트-개발자라면-알아야-할-33가지-개념-8-자바스크립트-필수요소-IIFE-마스터하기)

### 8. IIFE, Modules and Namespaces

자바스크립트 함수와 함께 자주 사용되는 코딩 패턴 중 하나는 **Immediately-invoked Function Expression**이라는 멋진 이름을 갖고 있습니다. **IIFE** 로 잘 알려져 있고 발음할 때는 **"iffy"** 처럼 발음합니다.



#### 자연스러운 함수 정의

자바스크립트를 처음 접하는 개발자들은 함수를 다룰 때 다음 문법이 편할 것입니다.

```js
function sayHi() {
  alert("Hello, World!");  
}

sayHi();
```



#### 익명 함수 표현식

이제 자바스크립트에 관한 것들이 재밌어질 때입니다. 함수 표현식이 어떻게 생겼는지 살펴봅시다.

```js
var msg = "Hello, World!";
var sayHi = function() {
  alert(msg);  
};

sayHi(); // 브라우저에서 "Hello, World!"라는 alert 메시지를 띄웁니다.
```

1. 1번째 줄은 ***msg\*** 변수를 선언하고 ***string\*** 값을 할당합니다.
2. 2-4번째 줄은 ***sayHi\*** 변수를 선언하고 ***function\*** 타입의 값을 할당합니다.
3. 6번째 줄은 ***sayHi\*** 함수를 호출합니다.



> 위의 예제에서, 할당의 right-hand에 있는 함수는 주로 **"함수 표현식(Function Expression)"** 이라 불립니다. 자바스크립트 내 어디든 있습니다. 콜백을 작성해봤다면 작성한 대부분의 콜백은 함수 표현식이었을 것입니다.



여러분은 아마 깊은 이해 없이 함수 표현식 자체는 많이 사용해봤을 것입니다. 하지만 함수 표현식을 마스터하는 것은 여러분에게 어떤 비밀스런 자바스크립트 초능력을 줄 것입니다.



> 그래서 여기서 기억할 중요한 개념은 자바스크립트에서 함수는 다른 값들과 거의 비슷하다는 것입니다. 할당 연산자의 right-hand 에도 올 수 있고, 또 다른 함수에 인자로도 넘겨질 수 있습니다.



#### 이름붙은(Named) 함수 표현식

함수 표현식은 이름을 가질 수 있습니다. 이름붙은 함수 표현식에서 가장 지루하고 가장 잘 알려진 용례는 재귀입니다. 하지만 지금은 걱정하지마세요. 이름붙은 함수 표현식의 이해 없이도 IIFE를 마스터하는 것은 가능합니다.

```js
var fibo = function fibonacci() {
  // 여기서 fibonacci() 함수를 호출할 수 있습니다.
  // 이 함수 표현식이 이름을 갖고 있기 때문입니다.
}

// 여기서 fibonacci()를 호출하면 실패합니다. 하지만 fibo()는 동작합니다.
```

여기서 차이점은 함수 표현식이 **"fibonacci"** 라는 이름을 가졌다는 것입니다. 또 이름을 가졌기 때문에, fibonacci 함수 내부에서 자신을 재귀적으로 호출할 수 있습니다. (사실 이것과 관련된 지식은 많이 있습니다. 함수 이름이 stack-trace 등 에서 보여지고 하는 것들요. 그런데 이번 튜토리얼에서는 그런것들은 크게 신경쓰지 않을 겁니다.)



함수 정의와 함수 표현식을 배웠습니다. 이젠 IIFE의 비밀스런 세계로 빠져봅시다. IIFE는 몇가지 문체의 방식으로 쓰여집니다. 먼저, 첫번째 방식을 봅시다. 이건 정말 정말 이해하기 쉽습니다.

```js
!function() {
  alert("Hello from IIFE!");  
}();
// "Hello from IIFE" 메시지를 보여줍니다.
```

귀여운 IIFE 친구가 동작합니다! 이 코드를 복사해서 브라우저 콘솔에서 실행해보려 할 때, 2번째 줄에서 alert를 볼 수 있을 것입니다. 그게 다 입니다. 누구도 이 alert를 다시 한번 보여줄 수 없습니다.

> 이 함수는 생명을 갖자마자 바로 죽어버립니다.

이제 직관적이지 않은 문법에 대해서 이해해봅시다. 첫번째 줄에 **"!"** 가 있던 것을 보셨을 겁니다. 만일 못보셨으면, 지금 보시면 됩니다.

1. 우리가 이전에 봤듯이, 함수 statement는 언제나 ***function\*** 이라는 키워드로 시작합니다. 자바스크립트가 유효한 statement에서 첫 단어로 ***function\*** 키워드를 볼 때마다, 자바스크립트는 함수 정의가 일어날 것이라고 예측합니다. 그래서 이러한 일이 일어나지 않도록 하기 위해서, 우리는 첫번째 줄 ***function\*** 키워드 앞에 **"!"** 를 붙여줍니다. 이렇게 하면 자바스크립트는 **"!"** 뒤에 온게 무엇이든지 표현식으로 다루게 됩니다.

> 그래서 우리는 생기자마자 바로 호출되는 함수 표현식을 얻었습니다. 우리 친구는 IIFE라 불리고 어떤 문체의 방식으로 쓰여지는지 상관 없이 효력을 발휘합니다.

위의 문체의 방식은 **"!"** 외에도 **"+"**, **"-"**, **"~"** 등 다양한 방식으로 작성해도 같은 결과를 보입니다. 1진 연산자면 아무 거나 이용해도 됩니다. 결국 목적은 뒤에 있는 함수를 식으로 만드는 것이니까요.



#### 클래식한 IIFE 스타일

위에서 쓴 IIFE 패턴은 이해하기 쉽습니다. 그래서 이해를 돕기 위해 더욱 전통적이고 널리 알려진 스타일보다 위의 스타일을 대신 사용했습니다.

> 위에서 본 IIFE 예제처럼, IIFE 패턴의 키는 함수를 만들고 식으로 변환하고 즉시 실행하는 것입니다.

그럼, 여기 다른 방식으로 함수 표현식을 만드는 방법을 봅시다.

```js
(function() {
  alert("I am not an IIFE yet!");  
});
```

위의 코드에서, 1-3번째 줄에서 함수 식이 괄호로 감싸져 있습니다. 위의 함수는 실행되지 않았기 때문에 아직 IIFE가 아닙니다. 이제 위 코드를 IIFE로 바꾸기 위해, 우리는 다음 두가지 문체를 따를 것입니다.



```js
// 문체 1
(function () {
  alert("I am an IIFE!");
}());

// 문체 2
(function () {
  alert("I am an IIFE, too!");
})();
```

이제 우리는 동작하는 2가지 IIFE를 알았습니다. 1번째 문체와 2번째 문체의 차이를 알아채는 것은 매우 어렵습니다. 그래서 제가 설명해드리겠습니다.

1. 첫번째 문체 4번째 줄에서, 함수 식을 호출하기 위한 **()** 괄호는 바깥 괄호 안에 포함됩니다. 또, 다시 바깥 괄호가 바깥 함수를 함수식으로 만들기 위해서 필요합니다.
2. 두번째 문체 9번째 줄에서, 함수 식을 호출하기 위한 **()** 괄호는 함수 표현식을 위한 감싸는 괄호 밖에 있습니다.



이쯤에서 작동하는 다음 예제와 작동하지 않는 2가지 예제를 보는 것으로 마무리 지읍시다. 우리는 지금부터 우리 IIFE의 이름을 지을 것입니다. 익명 함수를 사용하는 것은 그다지 좋은 아이디어가 아니기 때문입니다.

```js
// 유효한 IIFE
(function initGameIIFE() {
  // All your magical code to initialize the game!
}());

// 유효하지 않은 IIFE
function nonWorkingIIFE() {
    // 이제 왜 앞뒤로 괄호가 필요한지 알게 될 것입니다.
    // 괄호 없이는 그냥 함수 정의입니다. 표현식이 아닙니다.
    // 문법 에러가 날 것입니다.
}();

function () {
    // 여기서도 문법 에러가 날 것입니다.
}();
```

이제 왜 IIFE를 만들기 위해서 괄호로 감싸진 이상한 문법이 필요한지 알게 되었을 것입니다.



#### IIFE와 private변수

IIFE가 진짜 잘하는 것 중 하나는 IIFE를 위한 함수 스코프를 만드는 능력입니다.

> IIFE 내부에 정의된 어떤 변수라도 바깥 세상에서는 보이지 않습니다.

예제를 봅시다.

```js
(function IIFE_initGame() {
  // IIFE 밖에서는 접근할 수 없는 Private 변수들입니다.
  var lives;
  var weapons;
  
  init();
  
  // IIFE 밖에서는 접근할 수 없는 Private 함수입니다.
  function init() {
    lives = 5;
    weapons = 10;
  }
}());
```

이 예제에서, 우리는 IIFE 내부에 두개의 변수를 선언했습니다. 그리고 2개의 변수는 IIFE에 private합니다. IIFE 밖의 어느 누구도 그 변수들에 접근할 수 없습니다. 비슷하게, 우리는 **init** 함수가 있고 그 안에 있는 변수들은 IIFE 밖에서 누구도 접근할 수 없습니다. 하지만 **init** 함수에서는 바깥 변수에 접근 가능합니다.



#### 값을 리턴하는 IIFE

만일, IIFE로부터 반환 값이 필요하지 않다면, 그냥 우리가 처음 사용했던 것 처럼 **!, +, void** 와 같은 단항 연산자를 이용한 첫번째 문체의 IIFE를 계속 사용할 수도 있습니다.

> 하지만 다른 중요하고 강력한 IIFE의 기능 중 하나는 그들이 변수에 할당될 수 있는 값을 리턴할 수 있다는 데에 있습니다.

```js
var result = (function () {
  return "From IIFE";
}());

alert(result); // "From IIFE" 메시지를 출력합니다.
```

1. 우리는 이 문체 2번째 줄에서, statement를 반환하는 IIFE를 갖습니다.
2. 우리가 위의 코드를 실행할 때, 5번째 줄은 IIFE에서 반환된 값과 함께 alert 메시지를 보여줍니다.

기본적으로 IIFE는 당연히 즉시 실행됩니다. 그리고 반환된 값은 ***result\*** 변수에 할당됩니다.

이건 우리가 모듈 패턴의 예제처럼 사용하게 될 정말 강력한 패턴입니다.



#### 파라미터가 있는 IIFE

IIFE는 값을 리턴할 수 있을 뿐만 아니라, 호출될 때, 인자를 받을 수도 있습니다. 간단한 예제를 봅시다.

```js
(function IIFE(msg, times) {
  for (var i=1; i<=times; i++){
    console.log(msg);  
  }
}("Hello!", 5));
```

1. 위의 예제의 첫번째 줄에서, IIFE는 **msg, times** 각각 두개의 파라미터를 갖습니다.
2. 우리가 5번째 줄에서 IIFE를 실행할 때, 여태까지 사용했던 빈 괄호 **()** 대신에 인자(arguments)를 IIFE로 넘겼습니다.
3. 2번째 3번째 줄은 이 파라미터를 IIFE 내부에서 사용합니다.

이건 정말 강력한 패턴입니다. 그리고 jQuery 코드와 여타 라이브러리에서 이러한 형식이 자주 사용됩니다.



#### 클래식한 자바스크립트 모듈 패턴

이제 자바스크립트 IIFE를 마스터했습니다. 이제 IIFE와 클로져가 들어간 끝내주는 모듈 패턴을 봅시다.

우리는 클래식한 ***Sequence\*** 싱글톤 객체를 구현할 것입니다. 이 객체는 실수로 현재의 값이 오염되거나 하는 것 없이 제대로 작동합니다.

우리는 어떤 일이 일어나는지 순차적으로 이해하기 위해, 2단계에 걸쳐 이 코드를 작성할 것입니다.

```js
var Sequence = (function sequenceIIFE() {
  // 현재 counter 값을 저장하기 위한 Private 변수입니다.
  var current = 0;
  
  // IIFE에서 반환되는 객체입니다.
  return {
  };
  
}());

alert(typeof Sequence); // alert("Object");
```

1. 위의 예제에서 우리는 객체를 반환하는 IIFE를 만들었습니다. 7번째와 8번째 줄을 보시면 나옵니다.
2. 우리는 또 IIFE 내부에 ***current\***라는 이름을 갖는 지역 변수를 만들었습니다.
3. 이 예제에서 IIFE의 반환 값인 객체는 ***Sequence\***라는 변수에 할당됩니다. 12번째 줄에서는 우리가 IIFE에서 반환한 "object" 메시지를 올바르게 출력하고 있습니다.



이제 우리가 리턴하는 객체에 몇가지 함수를 추가하면서, 다음 단계로 가봅시다.

```js
var Sequence = (function sequenceIIFE() {

  // 현재 counter 값을 저장하기 위한 Private 변수
  var current = 0;
  
  // IIFE로 부터 반환 받는 객체
  return {
    getCurrentValue: function() {
      return current;  
    },
    
    getNextValue: function() {
      current = current + 1;
      return current;
    }
  };
  
}());

console.log(Sequence.getNextValue()); // 1
console.log(Sequence.getNextValue()); // 2
console.log(Sequence.getCurrentValue()); // 2
```

1. 이 예제에서, IIFE가 리턴하는 객체에 우리는 2가지 함수를 추가했습니다.
2. 8-10번째 줄은 ***current\*** 변수가 가진 값을 반환하는 ***getCurrentValue** 함수를 추가했습니다.
3. 12-15번째 줄은 ***current\*** 변수를 1 증가시키고 반환하는 ***getNextValue\*** 함수를 추가했습니다.

***current\*** 변수가 IIFE에서 private하기 때문에, 클로져를 통해 여기에 접근할 수 있는 함수 말고는 누구도 ***current\*** 변수의 값에 접근하거나 그 값을 수정할 수 없습니다.



#### 괄호를 생략할 때

함수 표현식에서 앞뒤에 괄호를 해주는 이유는 기본적으로 함수가 statement의 형태가 아닌 식(expression)의 형태가 되도록 만들어주기 위함입니다.

하지만 자바스크립트 엔진이 판단하기에 해당 코드가 명확히 함수 표현식이라면, 우리는 기술적으로 감싸는 괄호를 하지 않아도 될 것입니다. 아래의 예제처럼요.

```js
var result = funciton() {
  return "From IIFE!";
}();
```

위의 예제에서, ***function\*** 키워드는 statement의 첫번째 단어가 아닙니다. 그래서 자바스크립트 엔진은 이걸 statement 또는 정의(definition)로 판단하지 않습니다. 비슷하게, 식이라는게 명확하다면, 다른 곳에도 괄호를 생략할 수 있는 곳들이 있습니다.

하지만 저자는 언제나 괄호를 적는 것을 선호합니다. 위의 경우처럼 괄호가 필요 없는 경우까지요. 괄호를 사용하는 것은 가독성을 높여줍니다. 읽는 사람이 첫 줄만 보고도 그 함수가 IIFE가 될 것이라는 것을 알 수 있게 문체적으로 넌지시 힌트를 줍니다. 그들은 그들이 읽는 것이 IIFE라는 것을 알아내기 위해 끝까지 스크롤을 넘길 필요가 없습니다.